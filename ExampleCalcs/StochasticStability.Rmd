---
title: "**Supporting Calculations**"
subtitle: "Inferring stability and persistence in the vaginal microbiome: A stochastic model of ecological dynamics"
author: "Jose M Ponciano, Larrry J. Forney, Juan P. Gomez, Jacques Ravel"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
#  pdf_document:
    html_document:
      toc: true
      toc_float: true
      number_sections: true
      latex_engine: xelatex
#      extra_dependencies: ["flafter","caption"]
#      header-includes:
#  - \usepackage{placeins}
#  - \usepackage{caption}
#  - \renewcommand{\thefigure}{SI-\arabic{figure}}
#  - \def\itstar#1*{\textit{#1}\starON}
#  - \def\bfstar#1**{\textbf{#1}\starON}
#  - \def\bfitstar#1***{\textbf{\textit{#1}}\starON}
      editor_options:
      chunk_output_type: console
---

\clearpage

# Read me (begin here)

This file is the code used for our manuscript with same title above *submitted* to ***npj***. This is a practical tutorial aimed at giving a simple and intuitive introduction to fitting stochastic population dynamics models to microbial community ecology scientists. Our aim with this document is to present as simply as possible a quantitative approach to fit a continuous time stochastic population dynamics model to bacterial community time series data, with the goal of estimating stochastic stability metrics for the bacterial community, as described in the main text of our manuscript.  The code presented here was newly developed for this project.   

- The statistical theory used for parameter estimation was first developed in our 2014 paper funded by our microbiome project [Dennis & Ponciano, (2014)](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/13-1486.1).  This paper presents the fitting of a Stochastic Differential Equation with a Gompertz model, which upon log transformation (Ito transformation) becomes an OU process.  In particular, we show how this Ito transformation conveniently simplifies the problem of having having missing time points in the time series data.

- The computational methods to estimate the stochastic stability properties were originally developed in [Ives A.R., Dennis B., Cottingham K.L. and S.R. Carpenter](https://doi.org/10.1890/0012-9615(2003)073[0301:ECSAEI]2.0.CO;2), and reprogrammed in R by J.P. Gomez and J.M. Ponciano.  

- Simultaneously to this manuscript, J.M. Ponciano used the stochastic stability calculations of Ives et al in this exclusively computational/simulated data paper recently accepted for publication:
[Gaynor M.L., Kortessis N., Soltis D.E., Soltis P.S. and J.M. Ponciano ](https://www.journals.uchicago.edu/doi/10.1086/734411).  

- The application of Population Viability Monitoring ideas of [Staples *et al.*, 2005](https://conbio.onlinelibrary.wiley.com/doi/full/10.1111/j.1523-1739.2005.00283.x) to microbiome community data is new and programmed de-novo for this current manuscript.  

Finally, all code presented and used here was written by J.M. Ponciano and J.P. Gomez.

# Packages and functions

## Required packages
```{r package-loading, message=FALSE, warning=FALSE}
# From Venables and Ripley, the good old MASS to compute generalized inverses
library(MASS)

```

## Required function libraries
Here we import the functions in [Dennis & Ponciano, (2014)](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/13-1486.1) that we originally presented in the function library **ROUSSE2.0**.  

```{r loading-function-libraries, eval=FALSE}
# Import the OU population dynamics functions from
# Dennis and Ponciano 2014
source("ExampleCalcs/R/ROUSS/ROUSSE-2.0.R")

```

The functions uploaded in the `ROUSSE-2.0` library include 

- `ROUSS.CALCS()`:  A wrapper for all the functions in the library listed below.  This is function can be called with a single line and computes all the OU process calculations as well. It is meant to free the user from the hassle of having to learn how every single one of the functions below, also called by this library, works.  These other functions are:
- `correct.time()`: used to make sure the entered vector of time steps does not have mistakes
- `negloglike.OU.ml()`: The negative log-likelihood function to fit the population dynamics OU model
- `negloglike.OU.reml()`: The negative log-likelihood function used to fit the OU model via Restricted Maximum Likelihood 
- `randmvn()`: our own Multivariate Normal random number generator (coded here to minimize dependencies with other libraries)
- `ROUSS.sim()`: function to simulate data according to the OU model.  This function is used to compute numerically the time-dependent estimates of persistence probability for a species of interest as explained in the manuscript.
- `guess.calc()`: a function to compute a good starting point of the OU model parameters for the optimization process.
- `ROUSS.ML()`: a wrapper function using the functions `correct.time()`, `negloglike.OU.ml()`, `randmvn()` and  `guess.calc()` to return the ML estimates of the OU model parameters, for one species.
- `ROUSS.REML()`: a wrapper function using the functions `correct.time()`, `negloglike.OU.reml()`, `randmvn()` and  `guess.calc()` to return the REML estimates of the OU model parameters, for one species.  Dennis, Ponciano et al (2006) demonstrated that the REML estimates often have better statistical properties (less bias) than the ML estimates when the time series data are short in length.
- `ROUSS.predict()`: a function to calculate the estimated abundances after accounting for sampling error.  These are the black circles wrapped by a gray confidence band as seen in Figure 4 in the main manuscript.  The outcome of this function is THE single most important outcome to do the stability calculations as we show below. Note that this function outputs as well the maximum likelihood estimated abundances of the population process for time steps with missing observations.  To be able to compute the confidence bands as seen in Figure 4, one needs the parametric bootstrap function below:
- `ROUSS.pboot()`: Do a parametric bootstrap (using either REML or ML) to estimate confidence intervals of model parameters as well as the confidence intervals of the predictions of the population abundances filtered from sampling error as seen in Figure 4 in the main manuscript. 

## Other useful functions
Here we load other useful functions that we created for this manuscript.

```{r loading-functions, eval=FALSE}

# Automatically choosing 'k' colours for plots from a colour-blind friendly palette
mycols.ftn <- function(n){
	d <- 360/n
	h <- cumsum(c(15,rep(d,(n-1))))
	return(hcl(h=h, c=100,l=65))
}

# My own PCA function with transparent calculations
source("ExampleCalcs/R/mypca.R")

```

Because the purpose of this help file is to show how to fit and work with a stochastic
population dynamics model for bacteria community data, here we do not recapitulate
the entire  data cleaning process, which can be found at the start of the file 
`HMP_metadata_updated_taxonomy_StR_CSTs_020619.R`.
The outcome of the code in that file are the raw time series of readcounts
anchored in estimates of total abundances, for every bacterial species of interest,
and for every bacterial community/subject, as explained in the methods and in 
the supplemental files. In order to not having to iterate the same code over and over
for every community data set, we created the function `nas.cleaning.R` which can be
simply uploaded by sourcing it:

```{r data-cleaning function, eval=FALSE}
source("ExampleCalcs/R/nas.cleaning.R")
```

Finally, before actually starting illustrating how the population dynamics model works, we just remind the user that the most relevant step of the data preparation process, besides removing `NA`'s using the function above is to determine if your time series for the $p$ species you are interested in is long enough. As explained in the section "Minimal sample size to fit a MAR model" in the main manuscript, if $n$ is the length of the time series in your data set and for each species you have $m \geq 1$ replicated counts, then a straightforward check is to verify that the inequality 
$$ (n-1)mp > 2p^{2} + p$$
holds true.  If so, then the model parameters are indeed estimable. In the file `HMP_metadata_updated_taxonomy_StR_CSTs_020619.R` we implemented this check automatically for all the available data (lines 160-195).

# Illustration of the MAR model parameter estimation process

## Filtering sampling error from the time series data of abundances
Ideally, the MAR model parameter estimation process and the sampling error filtering process are merged into a single estimation step.  As mentioned in the manuscript, there is currently still statistical debate regarding the merits of integrating all estimation into a one-step process.  Much discussion regarding estimability of model parameters and the quality of the estimates still abounds.  Examining the statistical properties of these estimators for community time series data is subject for another in-depth, statistical manuscript.  Here, as explained in the main manuscript, we do first a sampling error filtering step followed by a MAR model and stochastic stability estimation step.  As long as one leaves the user the option to propagate the uncertainty from one estimation step into the next step (as our program does), this approach remains suitable.  There is always room for improving coding and statistical approaches but our main objective here is to illustrate code usage and concepts.

Anyways, enough said.  First, let's upload the cleaned raw data for all of our subjects (the outcome of running the file `HMP_metadata_updated_taxonomy_StR_CSTs_020619.R`)

```{r loading-rawdata, eval=FALSE}
load("ExampleCalcs/RData/allhmpdata3.0.RData")
load("ExampleCalcs/RData/integrateddata2.RData")

# Extracting the bacterial community abundances for the 25th listed community
samp.tss <- integrated.data2[[25]] # W-30

# Retrieving the vector of times, re-scaling it to start at 0
# and creating a longer vector of times that does not skip any time step.
# This last step is done because the original time vector might have missing 
# sampled days.
Time.t <- as.numeric(samp.tss$raw.days)
tt <- Time.t-Time.t[1]
long.t <- tt[1]:max(tt)

# Store the lengths of the short and long times vec. to use below
ithlens     <- length(Time.t) # here ithlens = 48
ithlong.lens <- length(long.t) # here ithlong.lens = 70
```

Note that since $70 - 48 = 22$ it means that there are $22$ days for which 
observations were missing for this particular bacterial community.  The OU 
calculations below predict the noise-filtered abundances for those missed days 
as well.  The statistical calculations done to get these estimates were NOT
published in [Dennis & Ponciano, (2014)](https://esajournals.onlinelibrary.wiley.com/doi/abs/10.1890/13-1486.1)
and hence constitute a new statistical tool, presented for the first time in 
this manuscript.  Below we do the noise filtering for a single time series as
an example, but in the main manuscript code we loop this calculation over all
bacteria species in each community (woman subject) and over all subject data.
This looping is done in the file `AllKalmanPreds.R`. Finally, instead of picking
a single bacteria species here, we pool together all the *Lactobacilli* 
abundances; recall that in the main manuscript we find that a community model
with just 2 species/types describes best the observed dynamics. Those two types
were the Lactobacilli and the rest of the species chosen (see main methods for
details).


```{r noise-filtered-abunds-II, eval=FALSE}
# Now  retrieving the total abundances of all Lactobacilli
# and putting them in log-scale for analysis:
all.lacto <- apply(samp.tss[,9:12],1,sum)
log.obs <- log(all.lacto)

# Setting the options for the `ROUSS.CALCS()` function:
# Do you want to compute the ML estimates or the REML estimates?
method <- "REML" # alternatively, set method <- "ML"
# Do you want to plot the predictions?
pred.plot <- "FALSE" # We do not want to immediately plot the predictions
# Do you want to plot the parametric bootstrap distribution of the estimates?
pboot.plot <- "FALSE" # Set it to "FALSE"  because we don't want the CI of the
                      # OU model parameters
NBoot <- 1000 # Number of bootstrap replicates for the CI of the noise filtered 
              # abundances (the predictions)

# And with just this one command, we can do all the Ponciano & Dennis OU 
# calculations, including the prediction.  We use 1000 bootstrap replicates

ts.results <- ROUSS.CALCS(Yobs=log.obs,Tvec=Time.t, pmethod=method, nboot=NBoot, 
                          plot.pred=pred.plot, plot.bootdists = pboot.plot);  


# Reading out the results:  the predictions with CI's for the time steps with
# observations AND for the time steps with missing observations
ts.pboot.cis <- ts.results$pboot.cis
longpred.mle <- ts.results$pboot.preds2[,3]
longpred.lci <- ts.results$pboot.preds2[,2]
longpred.uci <- ts.results$pboot.preds2[,4]

shortpred.mle <- ts.results$pboot.preds1[,3]
shortpred.lci <- ts.results$pboot.preds1[,2]
shortpred.uci <- ts.results$pboot.preds1[,4]
```

The results lead to the plot shown in Figure 4 in the main manuscript.  The
commands to do that plot are:

```{r noise-filtered-plot, eval=FALSE}
par(mar=c(3,3,3,1),  oma=c(2,2,2,1), mgp=c(2,0.5,0))
plot(tt,all.lacto, pch=1,type="n", bty="n", xlab="Time (days)", 
     ylab="Abundance of Lactobacilli")
polygon(x=c(long.t,rev(long.t)), y=c(longpred.lci,rev(longpred.uci)), 
        col="grey", border=NA)
points(tt,all.lacto, pch=1, type="b")
points(long.t,longpred.mle, pch=16, type="b")
legend("topleft", legend=c("Observed", "Estimated without sampling error"), 
       pch=c(1,16),bty="n")

```

which results in the plot
![Noise-filtered abundances](/Users/josemiguel/Documents/UFL/RESEARCH/LarryForney/NIH-grant-2012/Manuscript2023/NPJ-submission/Rfiles4Github/StochasticMicrobiome/ExampleCalcs/ExampleFigures/StochasticStability-Fig1.JPEG)

